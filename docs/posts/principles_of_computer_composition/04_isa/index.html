<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Instruction Set Architecture | Helia&#39;s Tech-Blog</title>
<meta name="keywords" content="ISA, Instruction Format, RISC-V">
<meta name="description" content="Instruction Formats Overview
1. What is an Instruction Format?
In most mainstream instruction set architectures (ISAs), an instruction is parsed from right to left in execution.
For example, after an instruction like:
ecall
It simply ends execution. But most other instructions contain:

rd: destination register
rs1, rs2: source registers

In RISC-V, instruction format strictly requires rs1 and rs2 to be placed at fixed bit positions in the 32-bit instruction word.

This avoids decoding complexity caused by variable field placement.">
<meta name="author" content="Helia">
<link rel="canonical" href="https://dev-helia.github.io/Tech-Blog-Website/posts/principles_of_computer_composition/04_isa/">
<link crossorigin="anonymous" href="/Tech-Blog-Website/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://dev-helia.github.io/Tech-Blog-Website/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://dev-helia.github.io/Tech-Blog-Website/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://dev-helia.github.io/Tech-Blog-Website/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://dev-helia.github.io/Tech-Blog-Website/apple-touch-icon.png">
<link rel="mask-icon" href="https://dev-helia.github.io/Tech-Blog-Website/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://dev-helia.github.io/Tech-Blog-Website/posts/principles_of_computer_composition/04_isa/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:url" content="https://dev-helia.github.io/Tech-Blog-Website/posts/principles_of_computer_composition/04_isa/">
  <meta property="og:site_name" content="Helia&#39;s Tech-Blog">
  <meta property="og:title" content="Instruction Set Architecture">
  <meta property="og:description" content="Instruction Formats Overview 1. What is an Instruction Format? In most mainstream instruction set architectures (ISAs), an instruction is parsed from right to left in execution.
For example, after an instruction like:
ecall It simply ends execution. But most other instructions contain:
rd: destination register rs1, rs2: source registers In RISC-V, instruction format strictly requires rs1 and rs2 to be placed at fixed bit positions in the 32-bit instruction word.
This avoids decoding complexity caused by variable field placement.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-03-31T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-03-31T00:00:00+00:00">
    <meta property="article:tag" content="ISA">
    <meta property="article:tag" content="Instruction Format">
    <meta property="article:tag" content="RISC-V">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Instruction Set Architecture">
<meta name="twitter:description" content="Instruction Formats Overview
1. What is an Instruction Format?
In most mainstream instruction set architectures (ISAs), an instruction is parsed from right to left in execution.
For example, after an instruction like:
ecall
It simply ends execution. But most other instructions contain:

rd: destination register
rs1, rs2: source registers

In RISC-V, instruction format strictly requires rs1 and rs2 to be placed at fixed bit positions in the 32-bit instruction word.

This avoids decoding complexity caused by variable field placement.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://dev-helia.github.io/Tech-Blog-Website/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Principles of Computer Composition",
      "item": "https://dev-helia.github.io/Tech-Blog-Website/posts/principles_of_computer_composition/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Instruction Set Architecture",
      "item": "https://dev-helia.github.io/Tech-Blog-Website/posts/principles_of_computer_composition/04_isa/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Instruction Set Architecture",
  "name": "Instruction Set Architecture",
  "description": "Instruction Formats Overview 1. What is an Instruction Format? In most mainstream instruction set architectures (ISAs), an instruction is parsed from right to left in execution.\nFor example, after an instruction like:\necall It simply ends execution. But most other instructions contain:\nrd: destination register rs1, rs2: source registers In RISC-V, instruction format strictly requires rs1 and rs2 to be placed at fixed bit positions in the 32-bit instruction word.\nThis avoids decoding complexity caused by variable field placement.\n",
  "keywords": [
    "ISA", "Instruction Format", "RISC-V"
  ],
  "articleBody": "Instruction Formats Overview 1. What is an Instruction Format? In most mainstream instruction set architectures (ISAs), an instruction is parsed from right to left in execution.\nFor example, after an instruction like:\necall It simply ends execution. But most other instructions contain:\nrd: destination register rs1, rs2: source registers In RISC-V, instruction format strictly requires rs1 and rs2 to be placed at fixed bit positions in the 32-bit instruction word.\nThis avoids decoding complexity caused by variable field placement.\n2. The 6 RISC-V Instruction Formats Format Description Examples R-Format Uses three register inputs add, xor, mul (arithmetic/logical) I-Format Contains immediate value, 1 source register addi, lw, jalr, slli S-Format Store-type instructions sw, sb SB-Format Branch instructions beq, bge U-Format Upper immediate (20-bit) instructions lui, auipc UJ-Format Jump-type instructions jal 3. Bit-Level Structure of Formats All RISC-V instructions are 32 bits wide.\nThe bit fields are assigned based on the instruction type. Below is a standard breakdown:\nR-Type: [ funct7 | rs2 | rs1 | funct3 | rd | opcode ] I-Type: [ imm[11:0] | rs1 | funct3 | rd | opcode ] S-Type: [ imm[11:5] | rs2 | rs1 | funct3 | imm[4:0] | opcode ] SB-Type: [ imm[12], imm[10:5], rs2, rs1, funct3, imm[4:1], imm[11], opcode ] U-Type: [ imm[31:12] | rd | opcode ] UJ-Type: [ imm[20], imm[10:1], imm[11], imm[19:12], rd, opcode ] Each format encodes information differently based on what is needed for that instruction.\n4. Why So Many Formats? Each instruction type serves different purposes and needs different fields:\nR-Type: needs 3 registers → rs1, rs2, rd I-Type: needs only one register + immediate → rs1, imm S-Type: uses split immediate → imm[11:5], imm[4:0] SB-Type: uses branch offset as an immediate → needs bit-rearranged imm U/UJ-Types: use large constants or absolute addresses (e.g., for jump or base) Each format ensures fixed decoding paths and consistent field positioning.\nISC-V Assembly Examples 1. Example: Load Array Elements and Constants .section .data arr: .word 2, 4, 6, 8 # Define an array n: .word 9 # Define an integer variable 'n' .section .text .globl _start _start: # Load the base address of arr into register a0 la a0, arr # a0 = base address of arr # Load array elements into a1–a4 lw a1, 0(a0) # a1 = arr[0] = 2 lw a2, 4(a0) # a2 = arr[1] = 4 lw a3, 8(a0) # a3 = arr[2] = 6 lw a4, 12(a0) # a4 = arr[3] = 8 # Load the value of variable n la a5, n # a5 = address of n lw a6, 0(a5) # a6 = value of n = 9 # Exit the program using ecall (syscall 10) li a7, 10 # syscall code 10 = exit ecall This demonstrates how .data and .text sections are used in RISC-V, and how addresses and values are handled using la (load address) and lw (load word).\n2. Example: Fibonacci Sequence in Assembly Below is a RISC-V assembly implementation of the Fibonacci sequence.\n# Fibonacci Sequence main: add t0, x0, x0 # t0 = 0 addi t1, x0, 1 # t1 = 1 la t3, n # t3 = address of n lw t3, 0(t3) # t3 = value of n fib: beq t3, x0, finish # if n == 0, jump to finish add t2, t0, t1 # t2 = t0 + t1 mv t0, t1 # move t1 → t0 mv t1, t2 # move t2 → t1 addi t3, t3, -1 # n = n - 1 j fib # jump to next iteration finish: addi a0, t0, 0 # prepare return value li a7, 1 # syscall code 1 = print integer ecall # print result li a7, 10 # syscall code 10 = exit ecall Notes: addi: add immediate value mv: pseudo-instruction for addi x, y, 0 beq: branch if equal j: unconditional jump (pseudoinstruction for jal x0, label) la: load address (pseudo-instruction expanded to auipc + addi) This example shows:\nRegister usage Looping Branching System calls via ecall This block clearly illustrates how a real algorithm like Fibonacci can be implemented directly in RISC-V instructions, showing you the flow of control and data step-by-step.\nShift Instructions \u0026 Formats 1. Shift Instructions 🧭 Instruction Format Summary Instruction Meaning sll rd, rs1, rs2 Shift Left Logical: rd = rs1 « rs2 slli rd, rs1, imm Shift Left Logical with immediate srl rd, rs1, rs2 Shift Right Logical: rd = rs1 » rs2 srli rd, rs1, imm Shift Right Logical with immediate sra rd, rs1, rs2 Shift Right Arithmetic (sign-preserving) srai rd, rs1, imm Shift Right Arithmetic with immediate These instructions shift the bits in rs1 and store the result in rd.\n2. R-Format Instruction Layout An R-type instruction is 32 bits wide and consists of the following fields:\nField Width (bits) Description funct7 7 Operation modifier rs2 5 Second source register rs1 5 First source register funct3 3 Operation selector rd 5 Destination register opcode 7 Operation category 31 25 24 20 19 15 14 12 11 7 6 0 [funct7][ rs2 ][ rs1 ][f3 ][ rd ][opcode] Note:\nAll fields are unsigned integers 5-bit fields represent values 0–31 (suitable for register numbers) funct3 and funct7 differentiate between similar instructions 3. I-Format Instruction Layout (for immediates) When an instruction has an immediate (like slli or srli), it uses I-type format.\nField Width (bits) Description imm[11:0] 12 Immediate value rs1 5 Source register funct3 3 Operation selector rd 5 Destination register opcode 7 Operation category 31 20 19 15 14 12 11 7 6 0 [ imm[11:0] ][ rs1 ][ f3 ][ rd ][opcode] Why I-format? 12 bits for the immediate field allow larger constants Only one source register (rs1) and one destination register (rd) Preserves simplicity for hardware decoder This section gives a compact overview of how bitwise shift operations are encoded and how R/I format structures differ.\nData Transfer Instructions 2. Data Transfer Instructions 🧭 Format: memop reg, offset(base_reg) memop = lw / sw / lb / sb / lh / sh / lbu / lhu reg = target register (for load) or source register (for store) offset = immediate value (in bytes) base_reg = register holding the base address The effective memory address is computed as:\neffective_address = base_reg + offset 3. Load Instructions Instruction Meaning lw rd, offset(rs1) Load 32-bit word from memory into rd lb rd, offset(rs1) Load 8-bit signed byte from memory into rd lbu rd, offset(rs1) Load 8-bit unsigned byte into rd lh rd, offset(rs1) Load 16-bit signed half-word lhu rd, offset(rs1) Load 16-bit unsigned half-word 4. Store Instructions Instruction Meaning sw rs2, offset(rs1) Store 32-bit word from rs2 into memory sb rs2, offset(rs1) Store lower 8 bits of rs2 into memory sh rs2, offset(rs1) Store lower 16 bits of rs2 into memory Note: All load/store addresses must be aligned if required by platform (e.g. 32-bit aligned for lw/sw)\n5. Register vs Memory Memory accesses are slower than registers Use registers (a0–a7 for arguments, a0–a1 for return values) when possible Stack memory is managed using sp (stack pointer) 6. Example (Assembly) .data var: .word 42 .text .globl _start _start: la a0, var # Load address of var lw a1, 0(a0) # Load 32-bit value from var to a1 (should be 42) li a2, 100 # Set a2 to 100 sw a2, 0(a0) # Store 100 back to var 7. Summary lw/sw: 32-bit word lh/sh: 16-bit half-word lb/sb: 8-bit byte lbu/lhu: load unsigned variant (no sign-extension) Choosing correct instruction ensures proper sign-extension and data width when transferring between memory and registers.\n3. Branching \u0026 Jump Instructions 1 Conditional Branches (SB-Format) Instruction Meaning beq rs1, rs2, label Branch if Equal bne rs1, rs2, label Branch if Not Equal blt rs1, rs2, label Branch if Less Than bge rs1, rs2, label Branch if Greater or Equal These instructions compare rs1 and rs2, and jump to the label if the condition is met.\nSB-Format encodes the target label using a 13-bit signed offset (from current PC). Offset is always 2-byte aligned, so encoded as offset / 2.\n2 Jump Instructions (UJ-Format \u0026 JAL) Instruction Purpose jal rd, label Jump and Link: set rd = PC + 4, then jump to label jalr rd, rs1, imm Jump and Link Register: PC = rs1 + imm, rd = PC + 4 The link part means saving the return address (i.e., where to come back) in rd.\nCommon pattern in function calls:\njal ra, func # Call function (store return address in ra) ... ret # Return (actually `jalr x0, ra, 0`) 3 Instruction Formats SB-Format (Branch) imm[12] | imm[10:5] | rs2 | rs1 | funct3 | imm[4:1] | imm[11] | opcode The 13-bit immediate is split across multiple fields. Must multiply by 2 to get actual byte offset. UJ-Format (jal) imm[20] | imm[10:1] | imm[11] | imm[19:12] | rd | opcode Immediate total 21 bits, signed. Also needs shift left by 1 (since all jumps are 2-byte aligned) I-Format (jalr) imm[11:0] | rs1 | funct3 | rd | opcode Same format as load instructions. Used in jalr for indirect jump (like function returns) 4 Assembly Example .globl _start _start: li t0, 0 # sum = 0 li t1, 10 # loop counter loop: add a0, a0, t0 # do something addi t0, t0, 1 blt t0, t1, loop # repeat if t0 \u003c t1 li a7, 10 ecall 5 Summary beq, bne, blt, bge are for condition-based control flow jal, jalr are used for function call/return Always use jalr for function returns Understand immediate encoding and format is crucial for ISA decoding Bitwise Operation Instructions Bitwise operations are commonly used for flag manipulation, masking, and low-level data manipulation.\n1 Register-to-Register Operations Instruction Description and rd, rs1, rs2 Bitwise AND or rd, rs1, rs2 Bitwise OR xor rd, rs1, rs2 Bitwise XOR These operations take two source registers and apply bitwise logic, storing the result in rd.\n2 Register-Immediate Operations Instruction Description andi rd, rs1, imm Bitwise AND with immediate ori rd, rs1, imm Bitwise OR with immediate xori rd, rs1, imm Bitwise XOR with immediate Immediate is usually used for masking specific bits, such as extracting the lower byte.\n3 Example: Masking Lower 8 Bits li t0, 0x1234 # Load a 16-bit value andi t1, t0, 0xFF # Mask and keep only the lower 8 bits # t1 = 0x34 This is a typical bitmask operation, often used in:\nExtracting specific byte from word Checking flag bits Performing low-level I/O operations 4 Summary and, or, xor operate on two registers andi, ori, xori combine register with constant Commonly used with masks like 0xFF, 0xF0, 0x0F No sign extension: bitwise logic applies bit-by-bit Arithmetic Instructions Arithmetic operations include basic add/subtract, multiplication/division, and immediate operations.\n1 Register-based Arithmetic Instruction Description add rd, rs1, rs2 Addition sub rd, rs1, rs2 Subtraction mul rd, rs1, rs2 Multiplication div rd, rs1, rs2 Division These use two register operands and return the result in rd.\n2 Immediate Arithmetic Instruction Description addi rd, rs1, imm Add with constant value Immediate must fit in 12-bit signed integer. Larger constants need to use lui.\n3 Example: Basic Arithmetic li t1, 10 li t2, 3 add t3, t1, t2 # t3 = 10 + 3 sub t4, t1, t2 # t4 = 10 - 3 mul t5, t1, t2 # t5 = 10 * 3 div t6, t1, t2 # t6 = 10 / 3 U-Type Format: Dealing with Large Immediates Sometimes, constants \u003e 12 bits are needed. I-Type only allows 12 bits.\nTo handle this, RISC-V defines U-Type (Upper Immediate) format.\n1 Instruction Format | imm[31:12] | rd | opcode | | 20 bits | 5 bits | 7 bits | 2 Supported Instructions Instruction Description lui Load Upper Immediate auipc Add Upper Immediate to PC They place a 20-bit value into the upper 20 bits of a register (imm \u003c\u003c 12), which can then be combined with addi.\n3 Example lui t0, 0x12345 # t0 = 0x12345000 addi t0, t0, 0x67 # t0 = 0x12345067 (final constant) This two-step process is how RISC-V constructs full 32-bit constants.\nSpecial Instruction nop: No Operation nop stands for “no operation”. When executed, it performs no effect on the program state. Implementation Detail In RISC-V, nop is a pseudo-instruction:\nnop # Equivalent to: addi x0, x0, 0 It uses register x0 (always 0), so it does nothing.\nCommon Use Cases Scenario Description Pipeline Padding Inserted to avoid hazards (especially in pipelined CPUs) Instruction Alignment Used to align instructions on memory boundaries Debugging/Breakpoints As placeholders when modifying instruction flow Delay Slots (legacy) In older architectures, sometimes used to fill delay slots nop is simple but often essential in low-level optimization and hardware debugging contexts.\n",
  "wordCount" : "2107",
  "inLanguage": "en",
  "datePublished": "2025-03-31T00:00:00Z",
  "dateModified": "2025-03-31T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Helia"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://dev-helia.github.io/Tech-Blog-Website/posts/principles_of_computer_composition/04_isa/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Helia's Tech-Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://dev-helia.github.io/Tech-Blog-Website/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://dev-helia.github.io/Tech-Blog-Website/" accesskey="h" title="Helia&#39;s Tech-Blog (Alt + H)">Helia&#39;s Tech-Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://dev-helia.github.io/Tech-Blog-Website/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://dev-helia.github.io/Tech-Blog-Website/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://dev-helia.github.io/Tech-Blog-Website/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://dev-helia.github.io/Tech-Blog-Website/">Home</a>&nbsp;»&nbsp;<a href="https://dev-helia.github.io/Tech-Blog-Website/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://dev-helia.github.io/Tech-Blog-Website/posts/principles_of_computer_composition/">Principles of Computer Composition</a></div>
    <h1 class="post-title entry-hint-parent">
      Instruction Set Architecture
    </h1>
    <div class="post-meta"><span title='2025-03-31 00:00:00 +0000 UTC'>March 31, 2025</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;2107 words&nbsp;·&nbsp;Helia

</div>
  </header> 
  <div class="post-content"><h1 id="instruction-formats-overview">Instruction Formats Overview<a hidden class="anchor" aria-hidden="true" href="#instruction-formats-overview">#</a></h1>
<h2 id="1-what-is-an-instruction-format">1. What is an Instruction Format?<a hidden class="anchor" aria-hidden="true" href="#1-what-is-an-instruction-format">#</a></h2>
<p>In most mainstream instruction set architectures (ISAs), an instruction is parsed from <strong>right to left</strong> in execution.</p>
<p>For example, after an instruction like:</p>
<pre tabindex="0"><code>ecall
</code></pre><p>It simply ends execution. But most other instructions contain:</p>
<ul>
<li><code>rd</code>: destination register</li>
<li><code>rs1</code>, <code>rs2</code>: source registers</li>
</ul>
<p>In <strong>RISC-V</strong>, instruction format <strong>strictly requires</strong> <code>rs1</code> and <code>rs2</code> to be placed at fixed bit positions in the 32-bit instruction word.</p>
<blockquote>
<p>This avoids decoding complexity caused by variable field placement.</p></blockquote>
<hr>
<h2 id="2-the-6-risc-v-instruction-formats">2. The 6 RISC-V Instruction Formats<a hidden class="anchor" aria-hidden="true" href="#2-the-6-risc-v-instruction-formats">#</a></h2>
<table>
  <thead>
      <tr>
          <th>Format</th>
          <th>Description</th>
          <th>Examples</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>R-Format</td>
          <td>Uses three register inputs</td>
          <td><code>add</code>, <code>xor</code>, <code>mul</code> (arithmetic/logical)</td>
      </tr>
      <tr>
          <td>I-Format</td>
          <td>Contains immediate value, 1 source register</td>
          <td><code>addi</code>, <code>lw</code>, <code>jalr</code>, <code>slli</code></td>
      </tr>
      <tr>
          <td>S-Format</td>
          <td>Store-type instructions</td>
          <td><code>sw</code>, <code>sb</code></td>
      </tr>
      <tr>
          <td>SB-Format</td>
          <td>Branch instructions</td>
          <td><code>beq</code>, <code>bge</code></td>
      </tr>
      <tr>
          <td>U-Format</td>
          <td>Upper immediate (20-bit) instructions</td>
          <td><code>lui</code>, <code>auipc</code></td>
      </tr>
      <tr>
          <td>UJ-Format</td>
          <td>Jump-type instructions</td>
          <td><code>jal</code></td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="3-bit-level-structure-of-formats">3. Bit-Level Structure of Formats<a hidden class="anchor" aria-hidden="true" href="#3-bit-level-structure-of-formats">#</a></h2>
<p>All RISC-V instructions are 32 bits wide.<br>
The bit fields are assigned based on the instruction type. Below is a standard breakdown:</p>
<pre tabindex="0"><code>R-Type:   [ funct7 | rs2 | rs1 | funct3 | rd | opcode ]
I-Type:   [ imm[11:0] | rs1 | funct3 | rd | opcode ]
S-Type:   [ imm[11:5] | rs2 | rs1 | funct3 | imm[4:0] | opcode ]
SB-Type:  [ imm[12], imm[10:5], rs2, rs1, funct3, imm[4:1], imm[11], opcode ]
U-Type:   [ imm[31:12] | rd | opcode ]
UJ-Type:  [ imm[20], imm[10:1], imm[11], imm[19:12], rd, opcode ]
</code></pre><blockquote>
<p>Each format encodes information differently based on what is needed for that instruction.</p></blockquote>
<hr>
<h2 id="4-why-so-many-formats">4. Why So Many Formats?<a hidden class="anchor" aria-hidden="true" href="#4-why-so-many-formats">#</a></h2>
<p>Each instruction type serves different purposes and needs different fields:</p>
<ul>
<li>R-Type: needs 3 registers → <code>rs1</code>, <code>rs2</code>, <code>rd</code></li>
<li>I-Type: needs only one register + immediate → <code>rs1</code>, <code>imm</code></li>
<li>S-Type: uses split immediate → <code>imm[11:5]</code>, <code>imm[4:0]</code></li>
<li>SB-Type: uses <strong>branch offset</strong> as an immediate → needs bit-rearranged <code>imm</code></li>
<li>U/UJ-Types: use large constants or absolute addresses (e.g., for jump or base)</li>
</ul>
<p>Each format ensures fixed decoding paths and consistent field positioning.</p>
<h1 id="isc-v-assembly-examples">ISC-V Assembly Examples<a hidden class="anchor" aria-hidden="true" href="#isc-v-assembly-examples">#</a></h1>
<h2 id="1-example-load-array-elements-and-constants">1. Example: Load Array Elements and Constants<a hidden class="anchor" aria-hidden="true" href="#1-example-load-array-elements-and-constants">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#a6e22e">.section</span> <span style="color:#66d9ef">.data</span>
</span></span><span style="display:flex;"><span>arr: <span style="color:#a6e22e">.word</span> <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span>        <span style="color:#75715e"># Define an array
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>n:   <span style="color:#a6e22e">.word</span> <span style="color:#ae81ff">9</span>                 <span style="color:#75715e"># Define an integer variable &#39;n&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">.section</span> <span style="color:#66d9ef">.text</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">.globl</span> <span style="color:#66d9ef">_start</span>
</span></span><span style="display:flex;"><span>_start:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Load the base address of arr into register a0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">la</span> <span style="color:#66d9ef">a0</span>, <span style="color:#66d9ef">arr</span>               <span style="color:#75715e"># a0 = base address of arr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Load array elements into a1–a4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">lw</span> <span style="color:#66d9ef">a1</span>, <span style="color:#ae81ff">0</span>(<span style="color:#66d9ef">a0</span>)             <span style="color:#75715e"># a1 = arr[0] = 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">lw</span> <span style="color:#66d9ef">a2</span>, <span style="color:#ae81ff">4</span>(<span style="color:#66d9ef">a0</span>)             <span style="color:#75715e"># a2 = arr[1] = 4
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">lw</span> <span style="color:#66d9ef">a3</span>, <span style="color:#ae81ff">8</span>(<span style="color:#66d9ef">a0</span>)             <span style="color:#75715e"># a3 = arr[2] = 6
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">lw</span> <span style="color:#66d9ef">a4</span>, <span style="color:#ae81ff">12</span>(<span style="color:#66d9ef">a0</span>)            <span style="color:#75715e"># a4 = arr[3] = 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Load the value of variable n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">la</span> <span style="color:#66d9ef">a5</span>, <span style="color:#66d9ef">n</span>                 <span style="color:#75715e"># a5 = address of n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">lw</span> <span style="color:#66d9ef">a6</span>, <span style="color:#ae81ff">0</span>(<span style="color:#66d9ef">a5</span>)             <span style="color:#75715e"># a6 = value of n = 9
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Exit the program using ecall (syscall 10)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">li</span> <span style="color:#66d9ef">a7</span>, <span style="color:#ae81ff">10</span>                <span style="color:#75715e"># syscall code 10 = exit
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ecall</span>
</span></span></code></pre></div><p>This demonstrates how <code>.data</code> and <code>.text</code> sections are used in RISC-V, and how addresses and values are handled using <code>la</code> (load address) and <code>lw</code> (load word).</p>
<hr>
<h2 id="2-example-fibonacci-sequence-in-assembly">2. Example: Fibonacci Sequence in Assembly<a hidden class="anchor" aria-hidden="true" href="#2-example-fibonacci-sequence-in-assembly">#</a></h2>
<p>Below is a RISC-V assembly implementation of the Fibonacci sequence.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span><span style="color:#75715e"># Fibonacci Sequence
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>main:   
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">add</span>   <span style="color:#66d9ef">t0</span>, <span style="color:#66d9ef">x0</span>, <span style="color:#66d9ef">x0</span>         <span style="color:#75715e"># t0 = 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">addi</span>  <span style="color:#66d9ef">t1</span>, <span style="color:#66d9ef">x0</span>, <span style="color:#ae81ff">1</span>          <span style="color:#75715e"># t1 = 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">la</span>    <span style="color:#66d9ef">t3</span>, <span style="color:#66d9ef">n</span>              <span style="color:#75715e"># t3 = address of n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">lw</span>    <span style="color:#66d9ef">t3</span>, <span style="color:#ae81ff">0</span>(<span style="color:#66d9ef">t3</span>)          <span style="color:#75715e"># t3 = value of n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>fib:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">beq</span>   <span style="color:#66d9ef">t3</span>, <span style="color:#66d9ef">x0</span>, <span style="color:#66d9ef">finish</span>     <span style="color:#75715e"># if n == 0, jump to finish
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">add</span>   <span style="color:#66d9ef">t2</span>, <span style="color:#66d9ef">t0</span>, <span style="color:#66d9ef">t1</span>         <span style="color:#75715e"># t2 = t0 + t1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mv</span>    <span style="color:#66d9ef">t0</span>, <span style="color:#66d9ef">t1</span>             <span style="color:#75715e"># move t1 → t0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">mv</span>    <span style="color:#66d9ef">t1</span>, <span style="color:#66d9ef">t2</span>             <span style="color:#75715e"># move t2 → t1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">addi</span>  <span style="color:#66d9ef">t3</span>, <span style="color:#66d9ef">t3</span>, -<span style="color:#ae81ff">1</span>         <span style="color:#75715e"># n = n - 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">j</span>     <span style="color:#66d9ef">fib</span>                <span style="color:#75715e"># jump to next iteration
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>finish:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">addi</span>  <span style="color:#66d9ef">a0</span>, <span style="color:#66d9ef">t0</span>, <span style="color:#ae81ff">0</span>          <span style="color:#75715e"># prepare return value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">li</span>    <span style="color:#66d9ef">a7</span>, <span style="color:#ae81ff">1</span>              <span style="color:#75715e"># syscall code 1 = print integer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ecall</span>                    <span style="color:#75715e"># print result
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">li</span>    <span style="color:#66d9ef">a7</span>, <span style="color:#ae81ff">10</span>             <span style="color:#75715e"># syscall code 10 = exit
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ecall</span>
</span></span></code></pre></div><h3 id="notes">Notes:<a hidden class="anchor" aria-hidden="true" href="#notes">#</a></h3>
<ul>
<li><code>addi</code>: add immediate value</li>
<li><code>mv</code>: pseudo-instruction for <code>addi x, y, 0</code></li>
<li><code>beq</code>: branch if equal</li>
<li><code>j</code>: unconditional jump (pseudoinstruction for <code>jal x0, label</code>)</li>
<li><code>la</code>: load address (pseudo-instruction expanded to <code>auipc</code> + <code>addi</code>)</li>
</ul>
<p>This example shows:</p>
<ul>
<li>Register usage</li>
<li>Looping</li>
<li>Branching</li>
<li>System calls via <code>ecall</code></li>
</ul>
<hr>
<p>This block clearly illustrates how a real algorithm like Fibonacci can be implemented directly in RISC-V instructions, showing you the flow of control and data step-by-step.</p>
<h1 id="shift-instructions--formats">Shift Instructions &amp; Formats<a hidden class="anchor" aria-hidden="true" href="#shift-instructions--formats">#</a></h1>
<h2 id="1-shift-instructions">1. Shift Instructions<a hidden class="anchor" aria-hidden="true" href="#1-shift-instructions">#</a></h2>
<h3 id="-instruction-format-summary">🧭 Instruction Format Summary<a hidden class="anchor" aria-hidden="true" href="#-instruction-format-summary">#</a></h3>
<table>
  <thead>
      <tr>
          <th>Instruction</th>
          <th>Meaning</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>sll rd, rs1, rs2</code></td>
          <td>Shift Left Logical: rd = rs1 &laquo; rs2</td>
      </tr>
      <tr>
          <td><code>slli rd, rs1, imm</code></td>
          <td>Shift Left Logical with immediate</td>
      </tr>
      <tr>
          <td><code>srl rd, rs1, rs2</code></td>
          <td>Shift Right Logical: rd = rs1 &raquo; rs2</td>
      </tr>
      <tr>
          <td><code>srli rd, rs1, imm</code></td>
          <td>Shift Right Logical with immediate</td>
      </tr>
      <tr>
          <td><code>sra rd, rs1, rs2</code></td>
          <td>Shift Right Arithmetic (sign-preserving)</td>
      </tr>
      <tr>
          <td><code>srai rd, rs1, imm</code></td>
          <td>Shift Right Arithmetic with immediate</td>
      </tr>
  </tbody>
</table>
<p>These instructions shift the bits in <code>rs1</code> and store the result in <code>rd</code>.</p>
<hr>
<h2 id="2-r-format-instruction-layout">2. R-Format Instruction Layout<a hidden class="anchor" aria-hidden="true" href="#2-r-format-instruction-layout">#</a></h2>
<p>An R-type instruction is 32 bits wide and consists of the following fields:</p>
<table>
  <thead>
      <tr>
          <th>Field</th>
          <th>Width (bits)</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>funct7</code></td>
          <td>7</td>
          <td>Operation modifier</td>
      </tr>
      <tr>
          <td><code>rs2</code></td>
          <td>5</td>
          <td>Second source register</td>
      </tr>
      <tr>
          <td><code>rs1</code></td>
          <td>5</td>
          <td>First source register</td>
      </tr>
      <tr>
          <td><code>funct3</code></td>
          <td>3</td>
          <td>Operation selector</td>
      </tr>
      <tr>
          <td><code>rd</code></td>
          <td>5</td>
          <td>Destination register</td>
      </tr>
      <tr>
          <td><code>opcode</code></td>
          <td>7</td>
          <td>Operation category</td>
      </tr>
  </tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>31      25 24   20 19   15 14  12 11   7 6    0
</span></span><span style="display:flex;"><span>[funct7][ rs2 ][ rs1 ][f3 ][ rd ][opcode]
</span></span></code></pre></div><p>Note:</p>
<ul>
<li>All fields are <strong>unsigned integers</strong></li>
<li>5-bit fields represent values 0–31 (suitable for register numbers)</li>
<li><code>funct3</code> and <code>funct7</code> differentiate between similar instructions</li>
</ul>
<hr>
<h2 id="3-i-format-instruction-layout-for-immediates">3. I-Format Instruction Layout (for immediates)<a hidden class="anchor" aria-hidden="true" href="#3-i-format-instruction-layout-for-immediates">#</a></h2>
<p>When an instruction has an immediate (like <code>slli</code> or <code>srli</code>), it uses I-type format.</p>
<table>
  <thead>
      <tr>
          <th>Field</th>
          <th>Width (bits)</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>imm[11:0]</code></td>
          <td>12</td>
          <td>Immediate value</td>
      </tr>
      <tr>
          <td><code>rs1</code></td>
          <td>5</td>
          <td>Source register</td>
      </tr>
      <tr>
          <td><code>funct3</code></td>
          <td>3</td>
          <td>Operation selector</td>
      </tr>
      <tr>
          <td><code>rd</code></td>
          <td>5</td>
          <td>Destination register</td>
      </tr>
      <tr>
          <td><code>opcode</code></td>
          <td>7</td>
          <td>Operation category</td>
      </tr>
  </tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>31        20 19   15 14  12 11   7 6    0
</span></span><span style="display:flex;"><span>[ imm[11:0] ][ rs1 ][ f3 ][ rd ][opcode]
</span></span></code></pre></div><h3 id="why-i-format">Why I-format?<a hidden class="anchor" aria-hidden="true" href="#why-i-format">#</a></h3>
<ul>
<li>12 bits for the immediate field allow larger constants</li>
<li>Only one source register (rs1) and one destination register (rd)</li>
<li>Preserves simplicity for hardware decoder</li>
</ul>
<hr>
<p>This section gives a compact overview of how <strong>bitwise shift operations</strong> are encoded and how <strong>R/I format structures</strong> differ.</p>
<h1 id="data-transfer-instructions">Data Transfer Instructions<a hidden class="anchor" aria-hidden="true" href="#data-transfer-instructions">#</a></h1>
<h2 id="2-data-transfer-instructions">2. Data Transfer Instructions<a hidden class="anchor" aria-hidden="true" href="#2-data-transfer-instructions">#</a></h2>
<h3 id="-format-memop-reg-offsetbase_reg">🧭 Format: <code>memop reg, offset(base_reg)</code><a hidden class="anchor" aria-hidden="true" href="#-format-memop-reg-offsetbase_reg">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>memop   = lw / sw / lb / sb / lh / sh / lbu / lhu
</span></span><span style="display:flex;"><span>reg     = target register (for load) or source register (for store)
</span></span><span style="display:flex;"><span>offset  = immediate value (in bytes)
</span></span><span style="display:flex;"><span>base_reg = register holding the base address
</span></span></code></pre></div><p>The effective memory address is computed as:</p>
<pre tabindex="0"><code>effective_address = base_reg + offset
</code></pre><hr>
<h2 id="3-load-instructions">3. Load Instructions<a hidden class="anchor" aria-hidden="true" href="#3-load-instructions">#</a></h2>
<table>
  <thead>
      <tr>
          <th>Instruction</th>
          <th>Meaning</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>lw rd, offset(rs1)</code></td>
          <td>Load 32-bit word from memory into <code>rd</code></td>
      </tr>
      <tr>
          <td><code>lb rd, offset(rs1)</code></td>
          <td>Load 8-bit signed byte from memory into <code>rd</code></td>
      </tr>
      <tr>
          <td><code>lbu rd, offset(rs1)</code></td>
          <td>Load 8-bit <strong>unsigned</strong> byte into <code>rd</code></td>
      </tr>
      <tr>
          <td><code>lh rd, offset(rs1)</code></td>
          <td>Load 16-bit signed half-word</td>
      </tr>
      <tr>
          <td><code>lhu rd, offset(rs1)</code></td>
          <td>Load 16-bit unsigned half-word</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="4-store-instructions">4. Store Instructions<a hidden class="anchor" aria-hidden="true" href="#4-store-instructions">#</a></h2>
<table>
  <thead>
      <tr>
          <th>Instruction</th>
          <th>Meaning</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>sw rs2, offset(rs1)</code></td>
          <td>Store 32-bit word from <code>rs2</code> into memory</td>
      </tr>
      <tr>
          <td><code>sb rs2, offset(rs1)</code></td>
          <td>Store lower 8 bits of <code>rs2</code> into memory</td>
      </tr>
      <tr>
          <td><code>sh rs2, offset(rs1)</code></td>
          <td>Store lower 16 bits of <code>rs2</code> into memory</td>
      </tr>
  </tbody>
</table>
<p>Note: All load/store addresses must be <strong>aligned</strong> if required by platform (e.g. 32-bit aligned for <code>lw/sw</code>)</p>
<hr>
<h2 id="5-register-vs-memory">5. Register vs Memory<a hidden class="anchor" aria-hidden="true" href="#5-register-vs-memory">#</a></h2>
<ul>
<li>Memory accesses are <strong>slower</strong> than registers</li>
<li>Use registers (<code>a0–a7</code> for arguments, <code>a0–a1</code> for return values) when possible</li>
<li>Stack memory is managed using <code>sp</code> (stack pointer)</li>
</ul>
<hr>
<h2 id="6-example-assembly">6. Example (Assembly)<a hidden class="anchor" aria-hidden="true" href="#6-example-assembly">#</a></h2>
<pre tabindex="0"><code class="language-assembly" data-lang="assembly">.data
var: .word 42

.text
.globl _start
_start:
    la a0, var        # Load address of var
    lw a1, 0(a0)      # Load 32-bit value from var to a1 (should be 42)
    li a2, 100        # Set a2 to 100
    sw a2, 0(a0)      # Store 100 back to var
</code></pre><hr>
<h2 id="7-summary">7. Summary<a hidden class="anchor" aria-hidden="true" href="#7-summary">#</a></h2>
<ul>
<li><code>lw/sw</code>: 32-bit word</li>
<li><code>lh/sh</code>: 16-bit half-word</li>
<li><code>lb/sb</code>: 8-bit byte</li>
<li><code>lbu/lhu</code>: load unsigned variant (no sign-extension)</li>
</ul>
<p>Choosing correct instruction ensures proper <strong>sign-extension</strong> and <strong>data width</strong> when transferring between memory and registers.</p>
<h1 id="3-branching--jump-instructions">3. Branching &amp; Jump Instructions<a hidden class="anchor" aria-hidden="true" href="#3-branching--jump-instructions">#</a></h1>
<h2 id="1-conditional-branches-sb-format">1 Conditional Branches (SB-Format)<a hidden class="anchor" aria-hidden="true" href="#1-conditional-branches-sb-format">#</a></h2>
<table>
  <thead>
      <tr>
          <th>Instruction</th>
          <th>Meaning</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>beq rs1, rs2, label</code></td>
          <td>Branch if Equal</td>
      </tr>
      <tr>
          <td><code>bne rs1, rs2, label</code></td>
          <td>Branch if Not Equal</td>
      </tr>
      <tr>
          <td><code>blt rs1, rs2, label</code></td>
          <td>Branch if Less Than</td>
      </tr>
      <tr>
          <td><code>bge rs1, rs2, label</code></td>
          <td>Branch if Greater or Equal</td>
      </tr>
  </tbody>
</table>
<p>These instructions compare <code>rs1</code> and <code>rs2</code>, and <strong>jump to the label</strong> if the condition is met.</p>
<p>SB-Format encodes the target label using a <strong>13-bit signed offset</strong> (from current PC). Offset is always <strong>2-byte aligned</strong>, so encoded as offset / 2.</p>
<hr>
<h2 id="2-jump-instructions-uj-format--jal">2 Jump Instructions (UJ-Format &amp; JAL)<a hidden class="anchor" aria-hidden="true" href="#2-jump-instructions-uj-format--jal">#</a></h2>
<table>
  <thead>
      <tr>
          <th>Instruction</th>
          <th>Purpose</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>jal rd, label</code></td>
          <td>Jump and Link: set <code>rd = PC + 4</code>, then jump to label</td>
      </tr>
      <tr>
          <td><code>jalr rd, rs1, imm</code></td>
          <td>Jump and Link Register: <code>PC = rs1 + imm</code>, <code>rd = PC + 4</code></td>
      </tr>
  </tbody>
</table>
<p>The <strong>link</strong> part means saving the return address (i.e., where to come back) in <code>rd</code>.</p>
<p>Common pattern in function calls:</p>
<pre tabindex="0"><code class="language-assembly" data-lang="assembly">jal ra, func     # Call function (store return address in ra)
...
ret              # Return (actually `jalr x0, ra, 0`)
</code></pre><hr>
<h2 id="3-instruction-formats">3 Instruction Formats<a hidden class="anchor" aria-hidden="true" href="#3-instruction-formats">#</a></h2>
<h3 id="sb-format-branch">SB-Format (Branch)<a hidden class="anchor" aria-hidden="true" href="#sb-format-branch">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>imm[12] | imm[10:5] | rs2 | rs1 | funct3 | imm[4:1] | imm[11] | opcode
</span></span></code></pre></div><ul>
<li>The 13-bit immediate is split across multiple fields.</li>
<li>Must multiply by 2 to get actual byte offset.</li>
</ul>
<h3 id="uj-format-jal">UJ-Format (jal)<a hidden class="anchor" aria-hidden="true" href="#uj-format-jal">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>imm[20] | imm[10:1] | imm[11] | imm[19:12] | rd | opcode
</span></span></code></pre></div><ul>
<li>Immediate total 21 bits, signed.</li>
<li>Also needs shift left by 1 (since all jumps are 2-byte aligned)</li>
</ul>
<h3 id="i-format-jalr">I-Format (jalr)<a hidden class="anchor" aria-hidden="true" href="#i-format-jalr">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>imm[11:0] | rs1 | funct3 | rd | opcode
</span></span></code></pre></div><ul>
<li>Same format as load instructions.</li>
<li>Used in <code>jalr</code> for indirect jump (like function returns)</li>
</ul>
<hr>
<h2 id="4-assembly-example">4 Assembly Example<a hidden class="anchor" aria-hidden="true" href="#4-assembly-example">#</a></h2>
<pre tabindex="0"><code class="language-assembly" data-lang="assembly">.globl _start
_start:
    li t0, 0         # sum = 0
    li t1, 10        # loop counter

loop:
    add a0, a0, t0   # do something
    addi t0, t0, 1
    blt t0, t1, loop # repeat if t0 &lt; t1

    li a7, 10
    ecall
</code></pre><hr>
<h2 id="5-summary">5 Summary<a hidden class="anchor" aria-hidden="true" href="#5-summary">#</a></h2>
<ul>
<li><code>beq</code>, <code>bne</code>, <code>blt</code>, <code>bge</code> are for condition-based control flow</li>
<li><code>jal</code>, <code>jalr</code> are used for function call/return</li>
<li>Always use <code>jalr</code> for <strong>function returns</strong></li>
<li>Understand immediate encoding and format is crucial for ISA decoding</li>
</ul>
<h1 id="bitwise-operation-instructions">Bitwise Operation Instructions<a hidden class="anchor" aria-hidden="true" href="#bitwise-operation-instructions">#</a></h1>
<p>Bitwise operations are commonly used for <strong>flag manipulation</strong>, <strong>masking</strong>, and <strong>low-level data manipulation</strong>.</p>
<h2 id="1-register-to-register-operations">1 Register-to-Register Operations<a hidden class="anchor" aria-hidden="true" href="#1-register-to-register-operations">#</a></h2>
<table>
  <thead>
      <tr>
          <th>Instruction</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>and rd, rs1, rs2</code></td>
          <td>Bitwise AND</td>
      </tr>
      <tr>
          <td><code>or rd, rs1, rs2</code></td>
          <td>Bitwise OR</td>
      </tr>
      <tr>
          <td><code>xor rd, rs1, rs2</code></td>
          <td>Bitwise XOR</td>
      </tr>
  </tbody>
</table>
<p>These operations take two source registers and apply bitwise logic, storing the result in <code>rd</code>.</p>
<hr>
<h2 id="2-register-immediate-operations">2 Register-Immediate Operations<a hidden class="anchor" aria-hidden="true" href="#2-register-immediate-operations">#</a></h2>
<table>
  <thead>
      <tr>
          <th>Instruction</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>andi rd, rs1, imm</code></td>
          <td>Bitwise AND with immediate</td>
      </tr>
      <tr>
          <td><code>ori rd, rs1, imm</code></td>
          <td>Bitwise OR with immediate</td>
      </tr>
      <tr>
          <td><code>xori rd, rs1, imm</code></td>
          <td>Bitwise XOR with immediate</td>
      </tr>
  </tbody>
</table>
<p>Immediate is usually used for <strong>masking specific bits</strong>, such as extracting the lower byte.</p>
<hr>
<h2 id="3-example-masking-lower-8-bits">3 Example: Masking Lower 8 Bits<a hidden class="anchor" aria-hidden="true" href="#3-example-masking-lower-8-bits">#</a></h2>
<pre tabindex="0"><code class="language-assembly" data-lang="assembly">li t0, 0x1234        # Load a 16-bit value
andi t1, t0, 0xFF    # Mask and keep only the lower 8 bits
# t1 = 0x34
</code></pre><p>This is a typical <strong>bitmask operation</strong>, often used in:</p>
<ul>
<li>Extracting specific byte from word</li>
<li>Checking flag bits</li>
<li>Performing low-level I/O operations</li>
</ul>
<hr>
<h2 id="4-summary">4 Summary<a hidden class="anchor" aria-hidden="true" href="#4-summary">#</a></h2>
<ul>
<li><code>and</code>, <code>or</code>, <code>xor</code> operate on two registers</li>
<li><code>andi</code>, <code>ori</code>, <code>xori</code> combine register with constant</li>
<li>Commonly used with masks like <code>0xFF</code>, <code>0xF0</code>, <code>0x0F</code></li>
<li>No sign extension: bitwise logic applies <strong>bit-by-bit</strong></li>
</ul>
<h1 id="arithmetic-instructions">Arithmetic Instructions<a hidden class="anchor" aria-hidden="true" href="#arithmetic-instructions">#</a></h1>
<hr>
<p>Arithmetic operations include basic add/subtract, multiplication/division, and immediate operations.</p>
<h2 id="1-register-based-arithmetic">1 Register-based Arithmetic<a hidden class="anchor" aria-hidden="true" href="#1-register-based-arithmetic">#</a></h2>
<table>
  <thead>
      <tr>
          <th>Instruction</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>add rd, rs1, rs2</code></td>
          <td>Addition</td>
      </tr>
      <tr>
          <td><code>sub rd, rs1, rs2</code></td>
          <td>Subtraction</td>
      </tr>
      <tr>
          <td><code>mul rd, rs1, rs2</code></td>
          <td>Multiplication</td>
      </tr>
      <tr>
          <td><code>div rd, rs1, rs2</code></td>
          <td>Division</td>
      </tr>
  </tbody>
</table>
<p>These use two register operands and return the result in <code>rd</code>.</p>
<hr>
<h2 id="2-immediate-arithmetic">2 Immediate Arithmetic<a hidden class="anchor" aria-hidden="true" href="#2-immediate-arithmetic">#</a></h2>
<table>
  <thead>
      <tr>
          <th>Instruction</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>addi rd, rs1, imm</code></td>
          <td>Add with constant value</td>
      </tr>
  </tbody>
</table>
<p>Immediate must fit in <strong>12-bit signed integer</strong>. Larger constants need to use <code>lui</code>.</p>
<hr>
<h2 id="3-example-basic-arithmetic">3 Example: Basic Arithmetic<a hidden class="anchor" aria-hidden="true" href="#3-example-basic-arithmetic">#</a></h2>
<pre tabindex="0"><code class="language-assembly" data-lang="assembly">li t1, 10
li t2, 3

add t3, t1, t2   # t3 = 10 + 3
sub t4, t1, t2   # t4 = 10 - 3
mul t5, t1, t2   # t5 = 10 * 3
div t6, t1, t2   # t6 = 10 / 3
</code></pre><hr>
<h1 id="u-type-format-dealing-with-large-immediates">U-Type Format: Dealing with Large Immediates<a hidden class="anchor" aria-hidden="true" href="#u-type-format-dealing-with-large-immediates">#</a></h1>
<hr>
<p>Sometimes, constants &gt; 12 bits are needed. I-Type only allows 12 bits.</p>
<p>To handle this, RISC-V defines <strong>U-Type</strong> (Upper Immediate) format.</p>
<h2 id="1-instruction-format">1 Instruction Format<a hidden class="anchor" aria-hidden="true" href="#1-instruction-format">#</a></h2>
<pre tabindex="0"><code>|  imm[31:12]  |   rd   | opcode |
|   20 bits    | 5 bits | 7 bits |
</code></pre><h2 id="2-supported-instructions">2 Supported Instructions<a hidden class="anchor" aria-hidden="true" href="#2-supported-instructions">#</a></h2>
<table>
  <thead>
      <tr>
          <th>Instruction</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>lui</code></td>
          <td>Load Upper Immediate</td>
      </tr>
      <tr>
          <td><code>auipc</code></td>
          <td>Add Upper Immediate to PC</td>
      </tr>
  </tbody>
</table>
<p>They place a 20-bit value into the upper 20 bits of a register (<code>imm &lt;&lt; 12</code>), which can then be combined with <code>addi</code>.</p>
<hr>
<h2 id="3-example">3 Example<a hidden class="anchor" aria-hidden="true" href="#3-example">#</a></h2>
<pre tabindex="0"><code class="language-assembly" data-lang="assembly">lui t0, 0x12345       # t0 = 0x12345000
addi t0, t0, 0x67     # t0 = 0x12345067 (final constant)
</code></pre><p>This two-step process is how RISC-V constructs <strong>full 32-bit constants</strong>.</p>
<h1 id="special-instruction">Special Instruction<a hidden class="anchor" aria-hidden="true" href="#special-instruction">#</a></h1>
<hr>
<h3 id="nop-no-operation"><code>nop</code>: No Operation<a hidden class="anchor" aria-hidden="true" href="#nop-no-operation">#</a></h3>
<ul>
<li><code>nop</code> stands for &ldquo;no operation&rdquo;.</li>
<li>When executed, it performs <strong>no effect</strong> on the program state.</li>
</ul>
<h3 id="implementation-detail">Implementation Detail<a hidden class="anchor" aria-hidden="true" href="#implementation-detail">#</a></h3>
<p>In RISC-V, <code>nop</code> is a <strong>pseudo-instruction</strong>:</p>
<pre tabindex="0"><code class="language-assembly" data-lang="assembly">nop     # Equivalent to: addi x0, x0, 0
</code></pre><p>It uses register x0 (always 0), so it does nothing.</p>
<hr>
<h3 id="common-use-cases">Common Use Cases<a hidden class="anchor" aria-hidden="true" href="#common-use-cases">#</a></h3>
<table>
  <thead>
      <tr>
          <th>Scenario</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Pipeline Padding</td>
          <td>Inserted to avoid hazards (especially in pipelined CPUs)</td>
      </tr>
      <tr>
          <td>Instruction Alignment</td>
          <td>Used to align instructions on memory boundaries</td>
      </tr>
      <tr>
          <td>Debugging/Breakpoints</td>
          <td>As placeholders when modifying instruction flow</td>
      </tr>
      <tr>
          <td>Delay Slots (legacy)</td>
          <td>In older architectures, sometimes used to fill delay slots</td>
      </tr>
  </tbody>
</table>
<p><code>nop</code> is simple but often essential in low-level optimization and hardware debugging contexts.</p>
<pre tabindex="0"><code></code></pre>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://dev-helia.github.io/Tech-Blog-Website/tags/isa/">ISA</a></li>
      <li><a href="https://dev-helia.github.io/Tech-Blog-Website/tags/instruction-format/">Instruction Format</a></li>
      <li><a href="https://dev-helia.github.io/Tech-Blog-Website/tags/risc-v/">RISC-V</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://dev-helia.github.io/Tech-Blog-Website/posts/principles_of_computer_composition/03_ieee754/">
    <span class="title">« Prev</span>
    <br>
    <span>Understanding IEEE 754 &amp; Fraction Encoding</span>
  </a>
  <a class="next" href="https://dev-helia.github.io/Tech-Blog-Website/posts/promptllery/">
    <span class="title">Next »</span>
    <br>
    <span>My First Full-Stack Project — Promptllery</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Instruction Set Architecture on x"
            href="https://x.com/intent/tweet/?text=Instruction%20Set%20Architecture&amp;url=https%3a%2f%2fdev-helia.github.io%2fTech-Blog-Website%2fposts%2fprinciples_of_computer_composition%2f04_isa%2f&amp;hashtags=ISA%2cInstructionFormat%2cRISC-V">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Instruction Set Architecture on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fdev-helia.github.io%2fTech-Blog-Website%2fposts%2fprinciples_of_computer_composition%2f04_isa%2f&amp;title=Instruction%20Set%20Architecture&amp;summary=Instruction%20Set%20Architecture&amp;source=https%3a%2f%2fdev-helia.github.io%2fTech-Blog-Website%2fposts%2fprinciples_of_computer_composition%2f04_isa%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Instruction Set Architecture on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fdev-helia.github.io%2fTech-Blog-Website%2fposts%2fprinciples_of_computer_composition%2f04_isa%2f&title=Instruction%20Set%20Architecture">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Instruction Set Architecture on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fdev-helia.github.io%2fTech-Blog-Website%2fposts%2fprinciples_of_computer_composition%2f04_isa%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Instruction Set Architecture on whatsapp"
            href="https://api.whatsapp.com/send?text=Instruction%20Set%20Architecture%20-%20https%3a%2f%2fdev-helia.github.io%2fTech-Blog-Website%2fposts%2fprinciples_of_computer_composition%2f04_isa%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Instruction Set Architecture on telegram"
            href="https://telegram.me/share/url?text=Instruction%20Set%20Architecture&amp;url=https%3a%2f%2fdev-helia.github.io%2fTech-Blog-Website%2fposts%2fprinciples_of_computer_composition%2f04_isa%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Instruction Set Architecture on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Instruction%20Set%20Architecture&u=https%3a%2f%2fdev-helia.github.io%2fTech-Blog-Website%2fposts%2fprinciples_of_computer_composition%2f04_isa%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://dev-helia.github.io/Tech-Blog-Website/">Helia&#39;s Tech-Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
