[{"content":"Hexadecimal and bit/byte Relationship Hexadecimal (Hex) is a base-16 system used to represent binary data. Its key relationships:\n1 hex digit = 4 bits (also called a nibble) 2 hex digits = 1 byte (8 bits) In computer systems:\n1 bit = smallest binary unit, can be 0 or 1 1 byte = 8 bits 1 nibble = 4 bits 1 word = usually 4 bytes (32 bits) 1 double word = usually 8 bytes (64 bits) Example: Hex vs Binary Table Hex Binary Size A 1010 4 bits (1 nibble) 3F 0011 1111 8 bits (1 byte) 7E2A 0111 1110 0010 1010 16 bits (2 bytes) FF AA 01 1111 1111 1010 1010 0000 0001 24 bits (3 bytes) Summary 1 hex digit = 4 bits 2 hex digits = 1 byte (8 bits) 8 hex digits = 4 bytes = 1 word = 32 bits Offset Bits and Block Size The number of offset bits depends on the block size, using this formula:\n[ \\text{Offset Bits} = \\log_2(\\text{Block Size}) ]\nFor example, if the block size is 8 bytes, then:\n[ \\log_2(8) = 3 \\text{ bits} ]\nSo 3 offset bits are needed to identify the exact byte inside the block:\nOffset Bits Meaning 000 Byte 0 001 Byte 1 010 Byte 2 \u0026hellip; \u0026hellip; 111 Byte 7 Note This concept is critical when dealing with cache addressing and memory hierarchy. Understanding how offset bits map into memory blocks helps later in cache tag/index/offset separation.\n","permalink":"https://dev-helia.github.io/Tech-Blog-Website/posts/principles_of_computer_composition/01_bit/","summary":"\u003ch2 id=\"hexadecimal-and-bitbyte-relationship\"\u003eHexadecimal and bit/byte Relationship\u003c/h2\u003e\n\u003cp\u003eHexadecimal (Hex) is a base-16 system used to represent binary data. Its key relationships:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e1 hex digit = 4 bits (also called a \u003cstrong\u003enibble\u003c/strong\u003e)\u003c/li\u003e\n\u003cli\u003e2 hex digits = 1 byte (8 bits)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn computer systems:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e1 bit\u003c/code\u003e = smallest binary unit, can be 0 or 1\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e1 byte\u003c/code\u003e = 8 bits\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e1 nibble\u003c/code\u003e = 4 bits\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e1 word\u003c/code\u003e = usually 4 bytes (32 bits)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e1 double word\u003c/code\u003e = usually 8 bytes (64 bits)\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"example-hex-vs-binary-table\"\u003eExample: Hex vs Binary Table\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eHex\u003c/th\u003e\n          \u003cth\u003eBinary\u003c/th\u003e\n          \u003cth\u003eSize\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eA\u003c/td\u003e\n          \u003ctd\u003e1010\u003c/td\u003e\n          \u003ctd\u003e4 bits (1 nibble)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e3F\u003c/td\u003e\n          \u003ctd\u003e0011 1111\u003c/td\u003e\n          \u003ctd\u003e8 bits (1 byte)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e7E2A\u003c/td\u003e\n          \u003ctd\u003e0111 1110 0010 1010\u003c/td\u003e\n          \u003ctd\u003e16 bits (2 bytes)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eFF AA 01\u003c/td\u003e\n          \u003ctd\u003e1111 1111 1010 1010 0000 0001\u003c/td\u003e\n          \u003ctd\u003e24 bits (3 bytes)\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003ch2 id=\"summary\"\u003eSummary\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e1 hex digit = 4 bits\u003c/li\u003e\n\u003cli\u003e2 hex digits = 1 byte (8 bits)\u003c/li\u003e\n\u003cli\u003e8 hex digits = 4 bytes = 1 word = 32 bits\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2 id=\"offset-bits-and-block-size\"\u003eOffset Bits and Block Size\u003c/h2\u003e\n\u003cp\u003eThe number of \u003cstrong\u003eoffset bits\u003c/strong\u003e depends on the \u003cstrong\u003eblock size\u003c/strong\u003e, using this formula:\u003c/p\u003e","title":"Hex \u0026 Binary Basics"},{"content":"Floating Point Encoding: Single Precision Use normalized base-2 scientific notation:\n+1.xxxxx... × 2^y IEEE 754 (32-bit float) splits into 3 fields: 1 bit: Sign (0 = positive, 1 = negative) 8 bits: Exponent (with bias) 23 bits: Significand / Mantissa Value = (–1)^Sign × 1.Significand × 2^(Exponent – Bias)\nBit Breakdown (32-bit float layout) Field Size Purpose Sign 1 bit 1 = negative, 0 = positive Exponent 8 bits Biased exponent Significand 23 bits Fractional part (assumes leading 1) Why Use Biased Notation for Exponent? If exponent were stored directly (signed int), comparison \u0026amp; sorting would be more complex.\nSo IEEE 754 uses bias notation, shifting exponent range to all positive values.\nBiased Formula: Actual exponent = Stored exponent – Bias Bias = 127 for float (32-bit) Bias = 1023 for double (64-bit) Example:\nStored exponent = 10000001₂ = 129 Actual exponent = 129 – 127 = 2 Exponent Value Table Actual Exponent Biased (Stored) Binary +127 254 1111 1110 0 127 0111 1111 –126 1 0000 0001 Special: ∞ / NaN 255 1111 1111 Negative exponents → closer to zero\nLarge biased values → ∞ or NaN\nSingle vs Double Precision Type Bit Length Significand Exponent Bias Float 32-bit 23 bits 8 bits 127 Double 64-bit 52 bits 11 bits 1023 Special Encoding Cases (IEEE 754) Case Exponent Significand Meaning Positive ∞ all 1s all 0s +∞ Negative ∞ all 1s all 0s –∞ NaN all 1s ≠ 0 Not a Number Zero all 0s all 0s +0 or –0 Denorm all 0s ≠ 0 Very small numbers (no leading 1) Note:\nSpecial encodings allow representation of edge cases like NaN, ∞, zero and subnormal numbers (denorms).\nYou’ll need this logic later in pipeline, FPU, and comparison instructions.\n","permalink":"https://dev-helia.github.io/Tech-Blog-Website/posts/principles_of_computer_composition/02_float/","summary":"\u003ch2 id=\"floating-point-encoding-single-precision\"\u003eFloating Point Encoding: Single Precision\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eUse \u003cstrong\u003enormalized\u003c/strong\u003e base-2 scientific notation:\u003cbr\u003e\n\u003ccode\u003e+1.xxxxx... × 2^y\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eIEEE 754 (32-bit float) splits into \u003cstrong\u003e3 fields\u003c/strong\u003e:\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e1 bit\u003c/strong\u003e: Sign (0 = positive, 1 = negative)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e8 bits\u003c/strong\u003e: Exponent (with bias)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e23 bits\u003c/strong\u003e: Significand / Mantissa\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eValue = (–1)^Sign × 1.Significand × 2^(Exponent – Bias)\u003c/p\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"bit-breakdown-32-bit-float-layout\"\u003eBit Breakdown (32-bit float layout)\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eField\u003c/th\u003e\n          \u003cth\u003eSize\u003c/th\u003e\n          \u003cth\u003ePurpose\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eSign\u003c/td\u003e\n          \u003ctd\u003e1 bit\u003c/td\u003e\n          \u003ctd\u003e1 = negative, 0 = positive\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eExponent\u003c/td\u003e\n          \u003ctd\u003e8 bits\u003c/td\u003e\n          \u003ctd\u003eBiased exponent\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eSignificand\u003c/td\u003e\n          \u003ctd\u003e23 bits\u003c/td\u003e\n          \u003ctd\u003eFractional part (assumes leading 1)\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003ch2 id=\"why-use-biased-notation-for-exponent\"\u003eWhy Use Biased Notation for Exponent?\u003c/h2\u003e\n\u003cp\u003eIf exponent were stored directly (signed int), comparison \u0026amp; sorting would be more complex.\u003cbr\u003e\nSo IEEE 754 uses \u003cstrong\u003ebias notation\u003c/strong\u003e, shifting exponent range to all positive values.\u003c/p\u003e","title":"Floating Point Encoding (IEEE 754)"},{"content":"Representing Fractions (Binary Point) Key Idea: Fixed Binary Point Use a fixed binary point to separate negative and non-negative powers:\nExample: 0b xx.xxxx (6-bit format) Each position represents:\n2^1 | 2^0 | . | 2^-1 | 2^-2 | ... Example:\n10.101 = 1×2^1 + 0×2^0 + 1×2^-1 + 0×2^-2 + 1×2^-3 = 2.625\nScientific Notation Use base-10 or base-2 scientific form:\n2.625 = 2 × 10^0 + 6 × 10^-1 + 2 × 10^-2 + 5 × 10^-3\nSo in binary:\n2.625 = 10.101 = 1×2^1 + 0×2^0 + 1×2^-1 + 0×2^-2 + 1×2^-3\nWhy IEEE 754 Is So Important? All CPUs, GPUs, and AI accelerators rely on floating-point math, especially IEEE 754:\nUsed in languages: float / double in C, C++, Java, Python, Rust\u0026hellip; Widely applied in physics, graphics, AI, simulations\u0026hellip; IEEE 754 Updates 2008: Added Half-Precision (16-bit) Extended to Quad Precision (128-bit) Focus on more flexible and accurate representations IEEE 754 Design Goals (1) Precision at Scale Accuracy matters for compounding operations\nIEEE 754 supports both 32-bit and 64-bit FP Results are deterministic and portable (for AI/ML) (2) Handling Floating-Point Errors Robust error cases:\nNaN (Not a Number): like 0.0 / 0.0 Overflow: exceeds max range Underflow: value too small to represent +0 and -0: IEEE allows signed zero for special edge cases These enhance numerical stability and prevent hidden bugs!\n(3) Compatibility with Two’s Complement IEEE 754 works in harmony with integer arithmetic:\n+0 in IEEE 754 is binary 000...0, same as integer +0 Ensures compatibility across int/float transitions Helps CPUs optimize under mixed integer/float workloads\nSummary:\nIEEE 754 isn’t just a spec—it’s a global standard for reliable math, powering everything from Pixar rendering to neural nets to finance tools.\nNext up, we’ll dive into instruction sets and how these formats are loaded into registers!\n","permalink":"https://dev-helia.github.io/Tech-Blog-Website/posts/principles_of_computer_composition/03_ieee754/","summary":"\u003ch2 id=\"representing-fractions-binary-point\"\u003eRepresenting Fractions (Binary Point)\u003c/h2\u003e\n\u003ch3 id=\"key-idea-fixed-binary-point\"\u003eKey Idea: Fixed Binary Point\u003c/h3\u003e\n\u003cp\u003eUse a fixed binary point to separate \u003cstrong\u003enegative\u003c/strong\u003e and \u003cstrong\u003enon-negative powers\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eExample: \u003ccode\u003e0b xx.xxxx\u003c/code\u003e (6-bit format)\u003c/li\u003e\n\u003cli\u003eEach position represents:\u003cbr\u003e\n\u003ccode\u003e2^1 | 2^0 | . | 2^-1 | 2^-2 | ...\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eExample:\u003cbr\u003e\n\u003ccode\u003e10.101\u003c/code\u003e = 1×2^1 + 0×2^0 + 1×2^-1 + 0×2^-2 + 1×2^-3 = \u003ccode\u003e2.625\u003c/code\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch3 id=\"scientific-notation\"\u003eScientific Notation\u003c/h3\u003e\n\u003cp\u003eUse base-10 or base-2 scientific form:\u003cbr\u003e\n\u003ccode\u003e2.625 = 2 × 10^0 + 6 × 10^-1 + 2 × 10^-2 + 5 × 10^-3\u003c/code\u003e\u003c/p\u003e","title":"Understanding IEEE 754 \u0026 Fraction Encoding"},{"content":"Instruction Formats Overview 1. What is an Instruction Format? In most mainstream instruction set architectures (ISAs), an instruction is parsed from right to left in execution.\nFor example, after an instruction like:\necall It simply ends execution. But most other instructions contain:\nrd: destination register rs1, rs2: source registers In RISC-V, instruction format strictly requires rs1 and rs2 to be placed at fixed bit positions in the 32-bit instruction word.\nThis avoids decoding complexity caused by variable field placement.\n2. The 6 RISC-V Instruction Formats Format Description Examples R-Format Uses three register inputs add, xor, mul (arithmetic/logical) I-Format Contains immediate value, 1 source register addi, lw, jalr, slli S-Format Store-type instructions sw, sb SB-Format Branch instructions beq, bge U-Format Upper immediate (20-bit) instructions lui, auipc UJ-Format Jump-type instructions jal 3. Bit-Level Structure of Formats All RISC-V instructions are 32 bits wide.\nThe bit fields are assigned based on the instruction type. Below is a standard breakdown:\nR-Type: [ funct7 | rs2 | rs1 | funct3 | rd | opcode ] I-Type: [ imm[11:0] | rs1 | funct3 | rd | opcode ] S-Type: [ imm[11:5] | rs2 | rs1 | funct3 | imm[4:0] | opcode ] SB-Type: [ imm[12], imm[10:5], rs2, rs1, funct3, imm[4:1], imm[11], opcode ] U-Type: [ imm[31:12] | rd | opcode ] UJ-Type: [ imm[20], imm[10:1], imm[11], imm[19:12], rd, opcode ] Each format encodes information differently based on what is needed for that instruction.\n4. Why So Many Formats? Each instruction type serves different purposes and needs different fields:\nR-Type: needs 3 registers → rs1, rs2, rd I-Type: needs only one register + immediate → rs1, imm S-Type: uses split immediate → imm[11:5], imm[4:0] SB-Type: uses branch offset as an immediate → needs bit-rearranged imm U/UJ-Types: use large constants or absolute addresses (e.g., for jump or base) Each format ensures fixed decoding paths and consistent field positioning.\nISC-V Assembly Examples 1. Example: Load Array Elements and Constants .section .data arr: .word 2, 4, 6, 8 # Define an array n: .word 9 # Define an integer variable \u0026#39;n\u0026#39; .section .text .globl _start _start: # Load the base address of arr into register a0 la a0, arr # a0 = base address of arr # Load array elements into a1–a4 lw a1, 0(a0) # a1 = arr[0] = 2 lw a2, 4(a0) # a2 = arr[1] = 4 lw a3, 8(a0) # a3 = arr[2] = 6 lw a4, 12(a0) # a4 = arr[3] = 8 # Load the value of variable n la a5, n # a5 = address of n lw a6, 0(a5) # a6 = value of n = 9 # Exit the program using ecall (syscall 10) li a7, 10 # syscall code 10 = exit ecall This demonstrates how .data and .text sections are used in RISC-V, and how addresses and values are handled using la (load address) and lw (load word).\n2. Example: Fibonacci Sequence in Assembly Below is a RISC-V assembly implementation of the Fibonacci sequence.\n# Fibonacci Sequence main: add t0, x0, x0 # t0 = 0 addi t1, x0, 1 # t1 = 1 la t3, n # t3 = address of n lw t3, 0(t3) # t3 = value of n fib: beq t3, x0, finish # if n == 0, jump to finish add t2, t0, t1 # t2 = t0 + t1 mv t0, t1 # move t1 → t0 mv t1, t2 # move t2 → t1 addi t3, t3, -1 # n = n - 1 j fib # jump to next iteration finish: addi a0, t0, 0 # prepare return value li a7, 1 # syscall code 1 = print integer ecall # print result li a7, 10 # syscall code 10 = exit ecall Notes: addi: add immediate value mv: pseudo-instruction for addi x, y, 0 beq: branch if equal j: unconditional jump (pseudoinstruction for jal x0, label) la: load address (pseudo-instruction expanded to auipc + addi) This example shows:\nRegister usage Looping Branching System calls via ecall This block clearly illustrates how a real algorithm like Fibonacci can be implemented directly in RISC-V instructions, showing you the flow of control and data step-by-step.\nShift Instructions \u0026amp; Formats 1. Shift Instructions 🧭 Instruction Format Summary Instruction Meaning sll rd, rs1, rs2 Shift Left Logical: rd = rs1 \u0026laquo; rs2 slli rd, rs1, imm Shift Left Logical with immediate srl rd, rs1, rs2 Shift Right Logical: rd = rs1 \u0026raquo; rs2 srli rd, rs1, imm Shift Right Logical with immediate sra rd, rs1, rs2 Shift Right Arithmetic (sign-preserving) srai rd, rs1, imm Shift Right Arithmetic with immediate These instructions shift the bits in rs1 and store the result in rd.\n2. R-Format Instruction Layout An R-type instruction is 32 bits wide and consists of the following fields:\nField Width (bits) Description funct7 7 Operation modifier rs2 5 Second source register rs1 5 First source register funct3 3 Operation selector rd 5 Destination register opcode 7 Operation category 31 25 24 20 19 15 14 12 11 7 6 0 [funct7][ rs2 ][ rs1 ][f3 ][ rd ][opcode] Note:\nAll fields are unsigned integers 5-bit fields represent values 0–31 (suitable for register numbers) funct3 and funct7 differentiate between similar instructions 3. I-Format Instruction Layout (for immediates) When an instruction has an immediate (like slli or srli), it uses I-type format.\nField Width (bits) Description imm[11:0] 12 Immediate value rs1 5 Source register funct3 3 Operation selector rd 5 Destination register opcode 7 Operation category 31 20 19 15 14 12 11 7 6 0 [ imm[11:0] ][ rs1 ][ f3 ][ rd ][opcode] Why I-format? 12 bits for the immediate field allow larger constants Only one source register (rs1) and one destination register (rd) Preserves simplicity for hardware decoder This section gives a compact overview of how bitwise shift operations are encoded and how R/I format structures differ.\nData Transfer Instructions 2. Data Transfer Instructions 🧭 Format: memop reg, offset(base_reg) memop = lw / sw / lb / sb / lh / sh / lbu / lhu reg = target register (for load) or source register (for store) offset = immediate value (in bytes) base_reg = register holding the base address The effective memory address is computed as:\neffective_address = base_reg + offset 3. Load Instructions Instruction Meaning lw rd, offset(rs1) Load 32-bit word from memory into rd lb rd, offset(rs1) Load 8-bit signed byte from memory into rd lbu rd, offset(rs1) Load 8-bit unsigned byte into rd lh rd, offset(rs1) Load 16-bit signed half-word lhu rd, offset(rs1) Load 16-bit unsigned half-word 4. Store Instructions Instruction Meaning sw rs2, offset(rs1) Store 32-bit word from rs2 into memory sb rs2, offset(rs1) Store lower 8 bits of rs2 into memory sh rs2, offset(rs1) Store lower 16 bits of rs2 into memory Note: All load/store addresses must be aligned if required by platform (e.g. 32-bit aligned for lw/sw)\n5. Register vs Memory Memory accesses are slower than registers Use registers (a0–a7 for arguments, a0–a1 for return values) when possible Stack memory is managed using sp (stack pointer) 6. Example (Assembly) .data var: .word 42 .text .globl _start _start: la a0, var # Load address of var lw a1, 0(a0) # Load 32-bit value from var to a1 (should be 42) li a2, 100 # Set a2 to 100 sw a2, 0(a0) # Store 100 back to var 7. Summary lw/sw: 32-bit word lh/sh: 16-bit half-word lb/sb: 8-bit byte lbu/lhu: load unsigned variant (no sign-extension) Choosing correct instruction ensures proper sign-extension and data width when transferring between memory and registers.\n3. Branching \u0026amp; Jump Instructions 1 Conditional Branches (SB-Format) Instruction Meaning beq rs1, rs2, label Branch if Equal bne rs1, rs2, label Branch if Not Equal blt rs1, rs2, label Branch if Less Than bge rs1, rs2, label Branch if Greater or Equal These instructions compare rs1 and rs2, and jump to the label if the condition is met.\nSB-Format encodes the target label using a 13-bit signed offset (from current PC). Offset is always 2-byte aligned, so encoded as offset / 2.\n2 Jump Instructions (UJ-Format \u0026amp; JAL) Instruction Purpose jal rd, label Jump and Link: set rd = PC + 4, then jump to label jalr rd, rs1, imm Jump and Link Register: PC = rs1 + imm, rd = PC + 4 The link part means saving the return address (i.e., where to come back) in rd.\nCommon pattern in function calls:\njal ra, func # Call function (store return address in ra) ... ret # Return (actually `jalr x0, ra, 0`) 3 Instruction Formats SB-Format (Branch) imm[12] | imm[10:5] | rs2 | rs1 | funct3 | imm[4:1] | imm[11] | opcode The 13-bit immediate is split across multiple fields. Must multiply by 2 to get actual byte offset. UJ-Format (jal) imm[20] | imm[10:1] | imm[11] | imm[19:12] | rd | opcode Immediate total 21 bits, signed. Also needs shift left by 1 (since all jumps are 2-byte aligned) I-Format (jalr) imm[11:0] | rs1 | funct3 | rd | opcode Same format as load instructions. Used in jalr for indirect jump (like function returns) 4 Assembly Example .globl _start _start: li t0, 0 # sum = 0 li t1, 10 # loop counter loop: add a0, a0, t0 # do something addi t0, t0, 1 blt t0, t1, loop # repeat if t0 \u0026lt; t1 li a7, 10 ecall 5 Summary beq, bne, blt, bge are for condition-based control flow jal, jalr are used for function call/return Always use jalr for function returns Understand immediate encoding and format is crucial for ISA decoding Bitwise Operation Instructions Bitwise operations are commonly used for flag manipulation, masking, and low-level data manipulation.\n1 Register-to-Register Operations Instruction Description and rd, rs1, rs2 Bitwise AND or rd, rs1, rs2 Bitwise OR xor rd, rs1, rs2 Bitwise XOR These operations take two source registers and apply bitwise logic, storing the result in rd.\n2 Register-Immediate Operations Instruction Description andi rd, rs1, imm Bitwise AND with immediate ori rd, rs1, imm Bitwise OR with immediate xori rd, rs1, imm Bitwise XOR with immediate Immediate is usually used for masking specific bits, such as extracting the lower byte.\n3 Example: Masking Lower 8 Bits li t0, 0x1234 # Load a 16-bit value andi t1, t0, 0xFF # Mask and keep only the lower 8 bits # t1 = 0x34 This is a typical bitmask operation, often used in:\nExtracting specific byte from word Checking flag bits Performing low-level I/O operations 4 Summary and, or, xor operate on two registers andi, ori, xori combine register with constant Commonly used with masks like 0xFF, 0xF0, 0x0F No sign extension: bitwise logic applies bit-by-bit Arithmetic Instructions Arithmetic operations include basic add/subtract, multiplication/division, and immediate operations.\n1 Register-based Arithmetic Instruction Description add rd, rs1, rs2 Addition sub rd, rs1, rs2 Subtraction mul rd, rs1, rs2 Multiplication div rd, rs1, rs2 Division These use two register operands and return the result in rd.\n2 Immediate Arithmetic Instruction Description addi rd, rs1, imm Add with constant value Immediate must fit in 12-bit signed integer. Larger constants need to use lui.\n3 Example: Basic Arithmetic li t1, 10 li t2, 3 add t3, t1, t2 # t3 = 10 + 3 sub t4, t1, t2 # t4 = 10 - 3 mul t5, t1, t2 # t5 = 10 * 3 div t6, t1, t2 # t6 = 10 / 3 U-Type Format: Dealing with Large Immediates Sometimes, constants \u0026gt; 12 bits are needed. I-Type only allows 12 bits.\nTo handle this, RISC-V defines U-Type (Upper Immediate) format.\n1 Instruction Format | imm[31:12] | rd | opcode | | 20 bits | 5 bits | 7 bits | 2 Supported Instructions Instruction Description lui Load Upper Immediate auipc Add Upper Immediate to PC They place a 20-bit value into the upper 20 bits of a register (imm \u0026lt;\u0026lt; 12), which can then be combined with addi.\n3 Example lui t0, 0x12345 # t0 = 0x12345000 addi t0, t0, 0x67 # t0 = 0x12345067 (final constant) This two-step process is how RISC-V constructs full 32-bit constants.\nSpecial Instruction nop: No Operation nop stands for \u0026ldquo;no operation\u0026rdquo;. When executed, it performs no effect on the program state. Implementation Detail In RISC-V, nop is a pseudo-instruction:\nnop # Equivalent to: addi x0, x0, 0 It uses register x0 (always 0), so it does nothing.\nCommon Use Cases Scenario Description Pipeline Padding Inserted to avoid hazards (especially in pipelined CPUs) Instruction Alignment Used to align instructions on memory boundaries Debugging/Breakpoints As placeholders when modifying instruction flow Delay Slots (legacy) In older architectures, sometimes used to fill delay slots nop is simple but often essential in low-level optimization and hardware debugging contexts.\n","permalink":"https://dev-helia.github.io/Tech-Blog-Website/posts/principles_of_computer_composition/04_isa/","summary":"\u003ch1 id=\"instruction-formats-overview\"\u003eInstruction Formats Overview\u003c/h1\u003e\n\u003ch2 id=\"1-what-is-an-instruction-format\"\u003e1. What is an Instruction Format?\u003c/h2\u003e\n\u003cp\u003eIn most mainstream instruction set architectures (ISAs), an instruction is parsed from \u003cstrong\u003eright to left\u003c/strong\u003e in execution.\u003c/p\u003e\n\u003cp\u003eFor example, after an instruction like:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eecall\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIt simply ends execution. But most other instructions contain:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003erd\u003c/code\u003e: destination register\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ers1\u003c/code\u003e, \u003ccode\u003ers2\u003c/code\u003e: source registers\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn \u003cstrong\u003eRISC-V\u003c/strong\u003e, instruction format \u003cstrong\u003estrictly requires\u003c/strong\u003e \u003ccode\u003ers1\u003c/code\u003e and \u003ccode\u003ers2\u003c/code\u003e to be placed at fixed bit positions in the 32-bit instruction word.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThis avoids decoding complexity caused by variable field placement.\u003c/p\u003e","title":"Instruction Set Architecture"},{"content":"Registers File reg[] 1. How Many Registers in RISC-V? RISC-V defines 32 general-purpose registers:\nx0 ~ x31 (each 32-bit, holds a word)\nTrade-off:\nMore registers = more variables can be stored But → harder to access quickly → slower hardware 2. Register Classification Type Alias Range Usage Hint Saved regs s0~s1 x8~x9 Values preserved across function calls s2~s11 x18~x27 Temp regs t0~t2 x5~x7 Temporary variables t3~t6 x28~x31 Note: Registers have no inherent type, unlike variables in C.\nTheir role depends on how you use them.\n3. Special Register: x0 (Zero Register) x0 is hardwired to 0\nAlways contains 0 Any attempt to write → has no effect Why useful?\nUsed in constant comparisons, clearing values, etc. Saves instruction space by avoiding explicit constants Summary Total: 32 registers (x0 to x31) Key takeaway: understand naming convention + classification + behavior ","permalink":"https://dev-helia.github.io/Tech-Blog-Website/posts/principles_of_computer_composition/05_registers/","summary":"\u003ch2 id=\"registers-file-reg\"\u003eRegisters File reg[]\u003c/h2\u003e\n\u003chr\u003e\n\u003ch3 id=\"1-how-many-registers-in-risc-v\"\u003e1. How Many Registers in RISC-V?\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eRISC-V defines \u003cstrong\u003e32 general-purpose registers\u003c/strong\u003e:\u003cbr\u003e\n\u003ccode\u003ex0\u003c/code\u003e ~ \u003ccode\u003ex31\u003c/code\u003e (each 32-bit, holds a \u003cstrong\u003eword\u003c/strong\u003e)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTrade-off:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMore registers = more variables can be stored\u003c/li\u003e\n\u003cli\u003eBut → harder to access quickly → slower hardware\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch3 id=\"2-register-classification\"\u003e2. Register Classification\u003c/h3\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eType\u003c/th\u003e\n          \u003cth\u003eAlias\u003c/th\u003e\n          \u003cth\u003eRange\u003c/th\u003e\n          \u003cth\u003eUsage Hint\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eSaved regs\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003es0\u003c/code\u003e~\u003ccode\u003es1\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ex8\u003c/code\u003e~\u003ccode\u003ex9\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003eValues preserved across function calls\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003es2\u003c/code\u003e~\u003ccode\u003es11\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ex18\u003c/code\u003e~\u003ccode\u003ex27\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eTemp regs\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003et0\u003c/code\u003e~\u003ccode\u003et2\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ex5\u003c/code\u003e~\u003ccode\u003ex7\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003eTemporary variables\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003et3\u003c/code\u003e~\u003ccode\u003et6\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003ex28\u003c/code\u003e~\u003ccode\u003ex31\u003c/code\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNote: Registers have \u003cstrong\u003eno inherent type\u003c/strong\u003e, unlike variables in C.\u003cbr\u003e\nTheir role depends on how you use them.\u003c/p\u003e","title":"Registers File reg[]"},{"content":"Clock Cycle A single-cycle CPU completes all stages of an instruction within one long clock cycle.\nEach instruction goes through the following five stages:\nInstruction Fetch Decode / Register Read Execute Memory Access Register Write Back The clock cycle is long enough to complete all these stages without interruption.\nInstruction Execution Stages (RISC-V) Stage Name Description IF Instruction Fetch Fetch the instruction from IMEM, increment PC += 4 ID Instruction Decode Decode the instruction, read rs1 and rs2 EX Execute Perform computation via ALU (arithmetic or address calculation) MEM Memory Access lw: read from memory; sw: write to memory WB Write Back Write result to rd Every instruction passes through IF, ID, EX, WB.\nOnly lw and sw instructions go through the MEM stage.\n","permalink":"https://dev-helia.github.io/Tech-Blog-Website/posts/principles_of_computer_composition/07_cpu/","summary":"\u003ch2 id=\"clock-cycle\"\u003eClock Cycle\u003c/h2\u003e\n\u003cp\u003eA \u003cstrong\u003esingle-cycle CPU\u003c/strong\u003e completes \u003cstrong\u003eall stages\u003c/strong\u003e of an instruction within \u003cstrong\u003eone long clock cycle\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eEach instruction goes through the following five stages:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eInstruction Fetch\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDecode / Register Read\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eExecute\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMemory Access\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRegister Write Back\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe clock cycle is long enough to complete all these stages without interruption.\u003c/p\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003ch2 id=\"instruction-execution-stages-risc-v\"\u003eInstruction Execution Stages (RISC-V)\u003c/h2\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eStage\u003c/th\u003e\n          \u003cth\u003eName\u003c/th\u003e\n          \u003cth\u003eDescription\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eIF\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003eInstruction Fetch\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003eFetch the instruction from \u003ccode\u003eIMEM\u003c/code\u003e, increment \u003ccode\u003ePC += 4\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eID\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003eInstruction Decode\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003eDecode the instruction, read \u003ccode\u003ers1\u003c/code\u003e and \u003ccode\u003ers2\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eEX\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003eExecute\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003ePerform computation via ALU (arithmetic or address calculation)\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eMEM\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003eMemory Access\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003elw\u003c/code\u003e: read from memory; \u003ccode\u003esw\u003c/code\u003e: write to memory\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eWB\u003c/td\u003e\n          \u003ctd\u003e\u003cstrong\u003eWrite Back\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003eWrite result to \u003ccode\u003erd\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cblockquote\u003e\n\u003cp\u003eEvery instruction passes through \u003cstrong\u003eIF, ID, EX, WB\u003c/strong\u003e.\u003cbr\u003e\nOnly \u003ccode\u003elw\u003c/code\u003e and \u003ccode\u003esw\u003c/code\u003e instructions go through the \u003cstrong\u003eMEM\u003c/strong\u003e stage.\u003c/p\u003e","title":"Clock Cycle and Instruction Stages"},{"content":"Why I Decided to Build a Full-Stack Project Honestly, the motivation wasn\u0026rsquo;t pure tech passion — it was anxiety from comparison. I saw classmates with polished full-stack projects, while I had only built algorithm demos or component pages.\nSo I forced myself to make something that looks like a full-stack product.\nOn the first day I broke down:\nWhat is JSX? What’s the deal between Vite and React? Why am I getting @babel/preset-react errors in testing? What\u0026rsquo;s the difference between Supabase and Node.js?\nI knew nothing — but I still started.\nThat’s why I decided to document every clueless moment. Even if it’s not useful to others, it’s proof that: I really walked this path.\nWhy This Project? While working on another project (Herthspace), I came across several prompt-sharing sites like PromptHero and Prompt Playground.\nIt hit me:\n“If they can build such fun AI content platforms\u0026hellip; why can’t I make one too?”\nBut what truly pushed me was seeing friends with end-to-end projects — frontend + backend + login + database — all fully connected. I wanted one too. I was jealous. 👀\nInstead of copying, I started comparing what those sites actually do:\nSite What inspired me PromptHero Prompt categorization + gallery → I want \u0026ldquo;Like\u0026rdquo; and \u0026ldquo;Save\u0026rdquo; PromptLand Prompt testing + model preview → I want \u0026ldquo;built-in model test\u0026rdquo; Pinterest Card-style UI → I want an aesthetic, fun, social-ish experience A lot of prompt sites look good, but feel passive. I wanted a site people actually want to save prompts from.\nSo Promptllery was born:\nA fun little prompt playground where:\nGood prompts can be saved Liked ones can be liked and shared Users can test prompts inline No GPT-4? Use share links and QR so no tokens are wasted! Thinking Backwards from Features to Stack At this point, I worked backwards to choose my stack:\nI want gallery-style layout → React + Tailwind I want to store prompts → Supabase I want interactivity (like/save) → useState/useEffect + Supabase I want prompt testing → OpenAI API (GPT-3.5 only) I want to save token costs → shareable links Eventually Promptllery became my playground — not to show off tech skills, but to practice product thinking.\nWhy This Tech Stack? I didn’t choose the stack intentionally — I just followed what others were using.\nBut I slowly realized: this is the perfect beginner-friendly \u0026ldquo;frontend-led\u0026rdquo; stack.\nTech What it is Why it fits Promptllery React JS library for UI Each prompt is a component; like/save = reactive state JSX HTML inside JS Makes component building fast \u0026amp; intuitive Tailwind CSS Utility-first CSS Perfect for rapid design and layout Vite Build tool Super fast dev server, built for modern frameworks Supabase Backend-as-a-service No backend code needed, but still have DB \u0026amp; Auth Jest + RTL Testing framework + helpers For ensuring component logic works as expected Vercel One-click deployment Perfect for student / solo projects Why not MERN? Because I want to focus on product logic and user experience, not API/infra.\nStack MERN (Mongo + Express) My stack (React + Supabase) Backend Dev You write everything Built-in API, no backend needed Database NoSQL (MongoDB) SQL (PostgreSQL, stable) Who it\u0026rsquo;s for Backend-focused devs MVP builders, frontend-heavy people What I Actually Built I started from zero — literally.\nModule Description Implementation Details Prompt Card Gallery List prompts with titles, tags, author PromptCard component + Tailwind layout Upload Form Create new prompts with title, desc, tags Controlled form → onSubmit sends to Supabase Like + Favorite Users can react to prompts Toggle useState + update Supabase row Search \u0026amp; Filter By keyword or tag Input + .filter() over prompt list Test Prompt Inline Run prompt with GPT Call OpenAI API and display result in frontend Share Tools Copy prompt, share QR navigator.clipboard.writeText, QR from lib Supabase Management Store/query prompt info, manage likes supabase.from(...).insert() or .update() Lessons from the Struggle I thought this was just a “temporary practice project”,\nBut it became proof of something deeper:\nThis was the first product I really built from scratch.\nProblem The Struggle How I Solved It Jest not reading JSX “Unexpected token” with \u0026lt;App /\u0026gt; Installed @babel/preset-react + created .babel.config.js Node version mismatch Packages required Node 18+ Used --force first, switched later Tailwind too verbose className chains were overwhelming Started using clsx() and layout planning Upload form bugged Wrong data or no state update Used controlled inputs + useEffect properly Vercel config confusion Didn’t know about Git linking or builds Learned .env, Git setup, and build settings Final Takeaways Before this project, I only admired what others had built.\nNow I know:\nPrompt sites can be built solo Supabase is beginner-friendly Testing is annoying but necessary Debugging is a superpower There’s a huge gap between “using” and “understanding” I can decide what a product looks like — not just follow others This isn’t a show-off piece. It’s my first real tech journey from: idea → research → design → build → debug → write → deploy.\nAnd I’ll never forget this feeling.\nDemo + User Flow I deployed it online (via Vercel)\nand recorded a short video to walk through the full user experience — from uploading prompts to sharing them.\nWhat\u0026rsquo;s Next? From solo to social\nAdd user accounts, profiles, and public prompt collections.\nLet users follow others, comment, and build a prompt culture.\nFrom gallery to ecosystem\nAdd categories, remixable prompt templates, and custom tags.\nBuild a real prompt library, not just a showcase.\nFrom testing to co-creation\nLet users build prompts together:\none writes the setup, another refines the wording, a third gives sample outputs.\nFrom passive use to community-driven feedback\nWeekly prompt picks, upvoting systems, feedback for creators.\nTurn prompts into a living dialogue, not static text.\nFrom student project to long-term playground\nEventually, maybe even invite contributors.\nOpen source parts, build an API, explore monetization for top creators?\nPromptllery is not just a website — it’s my first step into building something others might actually use.\nHope it becomes something meaningful and fun, even if it started out of jealousy.\n","permalink":"https://dev-helia.github.io/Tech-Blog-Website/posts/promptllery/","summary":"\u003ch2 id=\"why-i-decided-to-build-a-full-stack-project\"\u003eWhy I Decided to Build a Full-Stack Project\u003c/h2\u003e\n\u003cp\u003eHonestly, the motivation wasn\u0026rsquo;t pure tech passion — it was anxiety from comparison. I saw classmates with polished full-stack projects, while I had only built algorithm demos or component pages.\u003c/p\u003e\n\u003cp\u003eSo I forced myself to make something that \u003cem\u003elooks\u003c/em\u003e like a full-stack product.\u003c/p\u003e\n\u003cp\u003eOn the first day I broke down:\u003cbr\u003e\nWhat is JSX? What’s the deal between Vite and React? Why am I getting \u003ccode\u003e@babel/preset-react\u003c/code\u003e errors in testing? What\u0026rsquo;s the difference between Supabase and Node.js?\u003c/p\u003e","title":"My First Full-Stack Project — Promptllery"},{"content":"","permalink":"https://dev-helia.github.io/Tech-Blog-Website/posts/principles_of_computer_composition/06_circuits/","summary":"","title":""},{"content":"","permalink":"https://dev-helia.github.io/Tech-Blog-Website/posts/principles_of_computer_composition/08_datapath/","summary":"","title":""},{"content":"","permalink":"https://dev-helia.github.io/Tech-Blog-Website/posts/principles_of_computer_composition/09_pipeline/","summary":"","title":""},{"content":"","permalink":"https://dev-helia.github.io/Tech-Blog-Website/posts/principles_of_computer_composition/10_memory/","summary":"","title":""},{"content":"","permalink":"https://dev-helia.github.io/Tech-Blog-Website/posts/principles_of_computer_composition/11_cache/","summary":"","title":""}]